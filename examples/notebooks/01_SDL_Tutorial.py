{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Autonomous Drug Discovery Lab - Tutorial\n",
    "\n",
    "**Author:** Oluwaseun O. Ajayi  \n",
    "**Email:** seunolanikeajayi@gmail.com  \n",
    "**Date:** January 2025\n",
    "\n",
    "---\n",
    "\n",
    "## Welcome to Self-Driving Laboratories!\n",
    "\n",
    "This tutorial will guide you through creating your first autonomous optimization campaign using the SDL framework.\n",
    "\n",
    "### What You'll Learn:\n",
    "1. Setting up an SDL optimization problem\n",
    "2. Defining experimental workflows\n",
    "3. Running autonomous optimization\n",
    "4. Analyzing and visualizing results\n",
    "5. Understanding the efficiency gains\n",
    "\n",
    "### Prerequisites:\n",
    "```bash\n",
    "pip install autonomous-drug-discovery-lab\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 1: Understanding Self-Driving Labs\n",
    "\n",
    "### Traditional vs. SDL Approach\n",
    "\n",
    "**Traditional Optimization:**\n",
    "- Scientist designs experiment\n",
    "- Experiment is executed\n",
    "- Results are analyzed\n",
    "- Scientist designs next experiment (repeat)\n",
    "- üïê Slow, sequential, requires constant human input\n",
    "\n",
    "**SDL Optimization:**\n",
    "- Define parameter space and objective\n",
    "- SDL autonomously: designs ‚Üí executes ‚Üí analyzes ‚Üí learns ‚Üí repeats\n",
    "- ‚ö° Fast, parallel-capable, runs 24/7, optimal experimental design\n",
    "\n",
    "### Key Benefit: 85-95% Fewer Experiments!\n",
    "\n",
    "Instead of testing 1000s of conditions, SDL intelligently samples only the most informative experiments."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import required libraries\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from pathlib import Path\n",
    "\n",
    "# Import SDL framework\n",
    "from sdl_core.orchestrator import SDLOrchestrator, OptimizationConfig\n",
    "\n",
    "# Set plotting style\n",
    "sns.set_style('whitegrid')\n",
    "plt.rcParams['figure.figsize'] = (10, 6)\n",
    "plt.rcParams['figure.dpi'] = 100\n",
    "\n",
    "print(\"‚úì All imports successful!\")\n",
    "print(\"‚úì SDL framework ready\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 2: Define Your Experimental System\n",
    "\n",
    "Let's optimize a simple pharmaceutical formulation problem:\n",
    "- **Goal:** Maximize drug dissolution rate\n",
    "- **Parameters:** pH, surfactant concentration, temperature\n",
    "- **Objective:** Dissolution rate (% dissolved in 30 min)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def simulate_dissolution_experiment(params):\n",
    "    \"\"\"\n",
    "    Simulate drug dissolution experiment\n",
    "    \n",
    "    In reality, this would interface with:\n",
    "    - Dissolution testing apparatus\n",
    "    - UV-Vis spectrophotometer\n",
    "    - Automated sampling system\n",
    "    \"\"\"\n",
    "    pH = params['pH']\n",
    "    surfactant = params['surfactant_conc']  # mg/mL\n",
    "    temp = params['temperature']  # ¬∞C\n",
    "    \n",
    "    # Simulate dissolution kinetics (simplified)\n",
    "    # Optimal around pH 6.5, 2 mg/mL surfactant, 37¬∞C\n",
    "    \n",
    "    # pH effect (bell curve)\n",
    "    pH_factor = np.exp(-((pH - 6.5) / 1.5) ** 2)\n",
    "    \n",
    "    # Surfactant effect (plateau with optimal range)\n",
    "    if surfactant < 0.5:\n",
    "        surf_factor = surfactant / 0.5\n",
    "    elif surfactant < 3.0:\n",
    "        surf_factor = 1.0\n",
    "    else:\n",
    "        surf_factor = np.exp(-(surfactant - 3.0) / 2.0)\n",
    "    \n",
    "    # Temperature effect (Arrhenius-like)\n",
    "    temp_factor = np.exp(-((temp - 37) / 15) ** 2)\n",
    "    \n",
    "    # Combined effect\n",
    "    dissolution_rate = 85 * pH_factor * surf_factor * temp_factor\n",
    "    \n",
    "    # Add experimental noise (5%)\n",
    "    noise = np.random.normal(0, 0.05 * dissolution_rate)\n",
    "    observed_rate = max(0, min(100, dissolution_rate + noise))\n",
    "    \n",
    "    return {\n",
    "        'dissolution_30min': observed_rate,\n",
    "        'pH_measured': pH + np.random.normal(0, 0.05),\n",
    "        'turbidity': np.random.uniform(0, 10),\n",
    "        'time_seconds': 1800\n",
    "    }\n",
    "\n",
    "def analyze_dissolution_results(raw_data):\n",
    "    \"\"\"\n",
    "    Analyze experimental results\n",
    "    \"\"\"\n",
    "    return {\n",
    "        'objective_value': raw_data['dissolution_30min'],\n",
    "        'qc_passed': raw_data['dissolution_30min'] > 0,\n",
    "        'turbidity': raw_data['turbidity']\n",
    "    }\n",
    "\n",
    "print(\"‚úì Experimental system defined\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 3: Configure SDL Optimization\n",
    "\n",
    "Now we tell the SDL framework:\n",
    "- What parameters to optimize\n",
    "- What ranges to explore\n",
    "- How many experiments to run"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define parameter space\n",
    "config = OptimizationConfig(\n",
    "    objective=\"maximize\",  # We want maximum dissolution\n",
    "    parameter_space={\n",
    "        'pH': (4.0, 8.0),                    # pH range\n",
    "        'surfactant_conc': (0.1, 5.0),       # mg/mL\n",
    "        'temperature': (25.0, 45.0),         # ¬∞C\n",
    "    },\n",
    "    n_initial_experiments=10,   # Initial random sampling\n",
    "    max_iterations=25,          # Maximum optimization iterations\n",
    "    convergence_threshold=0.01, # Stop if improvement < 1%\n",
    "    exploration_weight=0.1      # Balance exploration vs exploitation\n",
    ")\n",
    "\n",
    "print(\"‚úì Optimization configured\")\n",
    "print(f\"\\nParameter Space:\")\n",
    "for param, (lower, upper) in config.parameter_space.items():\n",
    "    print(f\"  {param:20s}: [{lower:6.2f}, {upper:6.2f}]\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 4: Initialize SDL Orchestrator\n",
    "\n",
    "The orchestrator is the \"brain\" that coordinates everything."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create SDL orchestrator\n",
    "sdl = SDLOrchestrator(\n",
    "    config=config,\n",
    "    experiment_executor=simulate_dissolution_experiment,\n",
    "    result_analyzer=analyze_dissolution_results,\n",
    "    output_dir=\"tutorial_dissolution_output\"\n",
    ")\n",
    "\n",
    "print(\"‚úì SDL Orchestrator initialized\")\n",
    "print(f\"  Output directory: {sdl.output_dir}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 5: Run Autonomous Optimization! üöÄ\n",
    "\n",
    "Now sit back and watch the SDL work autonomously.\n",
    "\n",
    "The SDL will:\n",
    "1. Design initial experiments (random sampling)\n",
    "2. Execute each experiment\n",
    "3. Analyze results\n",
    "4. Build a predictive model (Gaussian Process)\n",
    "5. Decide the most informative next experiment\n",
    "6. Repeat until convergence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run the optimization campaign\n",
    "print(\"Starting SDL optimization campaign...\\n\")\n",
    "print(\"=\" * 70)\n",
    "\n",
    "results = sdl.run_optimization_campaign()\n",
    "\n",
    "print(\"\\n\" + \"=\" * 70)\n",
    "print(\"‚úì Optimization complete!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 6: Analyze Results\n",
    "\n",
    "Let's examine what the SDL discovered."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Extract key results\n",
    "best = results['best_result']\n",
    "summary = results['campaign_summary']\n",
    "\n",
    "print(\"=\" * 70)\n",
    "print(\"OPTIMIZATION RESULTS\")\n",
    "print(\"=\" * 70)\n",
    "\n",
    "print(\"\\nüìä OPTIMAL CONDITIONS FOUND:\")\n",
    "print(f\"  pH:                {best['parameters']['pH']:.2f}\")\n",
    "print(f\"  Surfactant:        {best['parameters']['surfactant_conc']:.2f} mg/mL\")\n",
    "print(f\"  Temperature:       {best['parameters']['temperature']:.1f} ¬∞C\")\n",
    "\n",
    "print(f\"\\nüéØ OPTIMAL DISSOLUTION RATE: {best['objective_value']:.1f}% in 30 min\")\n",
    "\n",
    "print(f\"\\nüìà CAMPAIGN STATISTICS:\")\n",
    "print(f\"  Total experiments:  {summary['completed_experiments']}\")\n",
    "print(f\"  Iterations:         {summary['iterations']}\")\n",
    "print(f\"  Success rate:       {summary['completed_experiments']/summary['total_experiments']*100:.1f}%\")\n",
    "\n",
    "if results['parameter_importance']:\n",
    "    print(f\"\\nüîç PARAMETER IMPORTANCE:\")\n",
    "    for param, importance in sorted(results['parameter_importance'].items(), \n",
    "                                    key=lambda x: x[1], reverse=True):\n",
    "        print(f\"  {param:20s}: {'‚ñà' * int(importance * 50)} {importance:.3f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 7: Visualize Optimization Trajectory"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create comprehensive visualization\n",
    "fig, axes = plt.subplots(2, 2, figsize=(14, 10))\n",
    "\n",
    "# Get data\n",
    "iterations = results['optimization_trajectory']['iterations']\n",
    "obj_values = results['optimization_trajectory']['objective_values']\n",
    "cumulative_best = results['optimization_trajectory']['cumulative_best']\n",
    "X_data = np.array(sdl.X_data)\n",
    "\n",
    "# Plot 1: Optimization trajectory\n",
    "ax1 = axes[0, 0]\n",
    "ax1.plot(iterations, obj_values, 'o-', alpha=0.6, label='Observed', markersize=6)\n",
    "ax1.plot(iterations, cumulative_best, 'r-', linewidth=2, label='Best So Far')\n",
    "ax1.axhline(y=best['objective_value'], color='green', linestyle='--', \n",
    "            alpha=0.7, label='Final Optimum')\n",
    "ax1.set_xlabel('Iteration', fontsize=11, fontweight='bold')\n",
    "ax1.set_ylabel('Dissolution Rate (% in 30 min)', fontsize=11, fontweight='bold')\n",
    "ax1.set_title('Optimization Trajectory', fontsize=13, fontweight='bold')\n",
    "ax1.legend()\n",
    "ax1.grid(True, alpha=0.3)\n",
    "\n",
    "# Plot 2: pH evolution\n",
    "ax2 = axes[0, 1]\n",
    "param_names = list(config.parameter_space.keys())\n",
    "pH_idx = param_names.index('pH')\n",
    "scatter = ax2.scatter(iterations, X_data[:, pH_idx], c=obj_values, \n",
    "                     cmap='viridis', s=80, edgecolor='black', linewidth=0.5)\n",
    "ax2.axhline(y=best['parameters']['pH'], color='red', linestyle='--', \n",
    "           linewidth=2, label='Optimal', alpha=0.8)\n",
    "ax2.set_xlabel('Iteration', fontsize=11, fontweight='bold')\n",
    "ax2.set_ylabel('pH', fontsize=11, fontweight='bold')\n",
    "ax2.set_title('pH Evolution', fontsize=13, fontweight='bold')\n",
    "ax2.legend()\n",
    "ax2.grid(True, alpha=0.3)\n",
    "plt.colorbar(scatter, ax=ax2, label='Dissolution Rate')\n",
    "\n",
    "# Plot 3: Surfactant evolution\n",
    "ax3 = axes[1, 0]\n",
    "surf_idx = param_names.index('surfactant_conc')\n",
    "ax3.scatter(iterations, X_data[:, surf_idx], c=obj_values,\n",
    "           cmap='viridis', s=80, edgecolor='black', linewidth=0.5)\n",
    "ax3.axhline(y=best['parameters']['surfactant_conc'], color='red',\n",
    "           linestyle='--', linewidth=2, label='Optimal', alpha=0.8)\n",
    "ax3.set_xlabel('Iteration', fontsize=11, fontweight='bold')\n",
    "ax3.set_ylabel('Surfactant Concentration (mg/mL)', fontsize=11, fontweight='bold')\n",
    "ax3.set_title('Surfactant Evolution', fontsize=13, fontweight='bold')\n",
    "ax3.legend()\n",
    "ax3.grid(True, alpha=0.3)\n",
    "\n",
    "# Plot 4: Temperature evolution\n",
    "ax4 = axes[1, 1]\n",
    "temp_idx = param_names.index('temperature')\n",
    "ax4.scatter(iterations, X_data[:, temp_idx], c=obj_values,\n",
    "           cmap='viridis', s=80, edgecolor='black', linewidth=0.5)\n",
    "ax4.axhline(y=best['parameters']['temperature'], color='red',\n",
    "           linestyle='--', linewidth=2, label='Optimal', alpha=0.8)\n",
    "ax4.set_xlabel('Iteration', fontsize=11, fontweight='bold')\n",
    "ax4.set_ylabel('Temperature (¬∞C)', fontsize=11, fontweight='bold')\n",
    "ax4.set_title('Temperature Evolution', fontsize=13, fontweight='bold')\n",
    "ax4.legend()\n",
    "ax4.grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig('tutorial_dissolution_output/optimization_trajectory.png', dpi=300, bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "print(\"‚úì Visualization saved\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 8: Calculate Efficiency Gains\n",
    "\n",
    "Let's compare SDL vs. traditional approaches."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate efficiency metrics\n",
    "n_sdl_experiments = summary['completed_experiments']\n",
    "\n",
    "# Traditional grid search would need:\n",
    "grid_points_per_param = 10\n",
    "n_params = len(config.parameter_space)\n",
    "n_grid_experiments = grid_points_per_param ** n_params\n",
    "\n",
    "# Efficiency\n",
    "experiments_saved = n_grid_experiments - n_sdl_experiments\n",
    "efficiency = (experiments_saved / n_grid_experiments) * 100\n",
    "\n",
    "# Time savings (assuming 30 min per experiment)\n",
    "time_per_exp = 30  # minutes\n",
    "grid_time = n_grid_experiments * time_per_exp / 60  # hours\n",
    "sdl_time = n_sdl_experiments * time_per_exp / 60  # hours\n",
    "time_saved = grid_time - sdl_time\n",
    "\n",
    "# Cost savings (assuming $50 per experiment)\n",
    "cost_per_exp = 50\n",
    "cost_saved = experiments_saved * cost_per_exp\n",
    "\n",
    "print(\"=\" * 70)\n",
    "print(\"EFFICIENCY ANALYSIS: SDL vs. Traditional Grid Search\")\n",
    "print(\"=\" * 70)\n",
    "\n",
    "print(\"\\nüìä EXPERIMENTS:\")\n",
    "print(f\"  SDL experiments:           {n_sdl_experiments}\")\n",
    "print(f\"  Grid search would need:    {n_grid_experiments:,}\")\n",
    "print(f\"  Experiments saved:         {experiments_saved:,}\")\n",
    "print(f\"  Efficiency gain:           {efficiency:.1f}%\")\n",
    "\n",
    "print(\"\\n‚è±Ô∏è  TIME:\")\n",
    "print(f\"  SDL time:                  {sdl_time:.1f} hours ({sdl_time/24:.1f} days)\")\n",
    "print(f\"  Grid search time:          {grid_time:.1f} hours ({grid_time/24:.1f} days)\")\n",
    "print(f\"  Time saved:                {time_saved:.1f} hours ({time_saved/24:.1f} days)\")\n",
    "\n",
    "print(\"\\nüí∞ COST:\")\n",
    "print(f\"  SDL cost:                  ${n_sdl_experiments * cost_per_exp:,}\")\n",
    "print(f\"  Grid search cost:          ${n_grid_experiments * cost_per_exp:,}\")\n",
    "print(f\"  Cost saved:                ${cost_saved:,}\")\n",
    "\n",
    "print(\"\\n\" + \"=\" * 70)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 9: Export Data\n",
    "\n",
    "Save all experimental data for further analysis or publication."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Export to CSV\n",
    "df = sdl.export_data(\"dissolution_optimization_data.csv\")\n",
    "\n",
    "print(\"‚úì Data exported to CSV\")\n",
    "print(f\"\\nDataFrame shape: {df.shape}\")\n",
    "print(f\"\\nFirst few experiments:\")\n",
    "display(df.head(10))\n",
    "\n",
    "print(f\"\\nSummary statistics:\")\n",
    "display(df.describe())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 10: Next Steps\n",
    "\n",
    "### üéØ You've Successfully:\n",
    "- ‚úÖ Set up an SDL optimization problem\n",
    "- ‚úÖ Run autonomous optimization\n",
    "- ‚úÖ Achieved 90%+ experiment reduction\n",
    "- ‚úÖ Found optimal conditions\n",
    "- ‚úÖ Visualized results\n",
    "- ‚úÖ Exported publication-ready data\n",
    "\n",
    "### üöÄ Try These Next:\n",
    "\n",
    "1. **Adapt to Your Problem:**\n",
    "   - Replace simulation functions with real instruments\n",
    "   - Adjust parameter space for your system\n",
    "   - Customize analysis pipeline\n",
    "\n",
    "2. **Explore More Examples:**\n",
    "   - Enzyme optimization\n",
    "   - ADMET screening\n",
    "   - Multi-objective optimization\n",
    "   - Kinetics determination\n",
    "\n",
    "3. **Read the Documentation:**\n",
    "   - Protocol papers in `docs/protocols/`\n",
    "   - Case studies in `docs/case_studies/`\n",
    "   - API reference\n",
    "\n",
    "4. **Integration:**\n",
    "   - Connect with your existing automation\n",
    "   - Link to LIMS systems\n",
    "   - Add custom analysis tools\n",
    "\n",
    "### üìö Resources:\n",
    "- GitHub: https://github.com/Oluwaseun-O-Ajayi/autonomous-drug-discovery-lab\n",
    "- Documentation: See `docs/` folder\n",
    "- Examples: See `examples/` folder\n",
    "\n",
    "### üìß Contact:\n",
    "**Oluwaseun O. Ajayi**  \n",
    "Email: seunolanikeajayi@gmail.com  \n",
    "ORCID: [0000-0003-0040-7217](https://orcid.org/0000-0003-0040-7217)\n",
    "\n",
    "---\n",
    "\n",
    "## üéâ Congratulations!\n",
    "\n",
    "You've completed the SDL tutorial. You're now ready to implement autonomous experimentation in your own laboratory!\n",
    "\n",
    "**Remember:** Self-driving labs aren't just about automation‚Äîthey're about intelligent, adaptive experimentation that learns and improves continuously."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}